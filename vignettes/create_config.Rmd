---
title: "Creating Configurations in gen3sis"
output: rmarkdown::html_vignette
date: "`r format(Sys.time(),  '%d.%m.%Y')`"
vignette: >
  %\VignetteIndexEntry{Creating Configuration}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The configuration object includes the customizable initialization, observer, speciation, dispersal, evolution and ecology functions. Altogether, these six functions are applied as defined in the simulation engine. The possibility to customize these functions confers the high flexibility of *gen3sis* in terms of including a wide range of theoretical knowledge. Additionally, the configuration object lists the model settings, i.e. the ecological traits considered in the simulation: whether a random seed is used; allowing simulation reproducibility; start and end times of the simulation; and rules about aborting the simulation, including the maximum global or local species number permitted. 

This vignette will guide you trough the config input object. It can be either an R object or a file, that can be easily shared and modified.

Here we will:

[1. **Create a config**](#create) form scratch.

[2. **Modify a config**](#modify)

[3. **Explore config**](#explore), where we will go over the config elements used at the [introduction.html](this vignette) vignette.


```{r setup}
library(gen3sis)
```

## 1. Create a config from scratch {#create}


In order to create an empty config, we use the function *write_config_skeleton* and define the output location. For that we have to define where the empty config will be stored.

```{r eval=TRUE}
# get data path
datapath <- system.file(file.path("extdata", "EmptyConfig"), package="gen3sis")
# set config_empty.R file path
config_file_path <- file.path(datapath, "EmptyConfig", "config_empty.R")
```

And then create an empty config.

```{r eval=FALSE, message=FALSE}
#writes out a config skeleton
write_config_skeleton(config_file_path)
```
This is how the config_empty.R looks like. We present them by main areas and each part is described briefly.


::: {.infobox .caution data-latex="{caution}"}
> ## **Content of config.empty.R**
>
>***Settings***
>```{r eval=FALSE}
# set the random seed for the simulation.
random_seed = NA
# set the starting time step or leave NA to use the earliest/highest time-step.
start_time = NA
# set the end time step or leave as NA to use the latest/lowest time-step (0).
end_time = NA
# maximum total number of species in the simulation before it is aborted.
max_number_of_species = 25000
# maximum number of species within one cell before the simulation is aborted.
max_number_of_coexisting_species = 2500
# a list of traits to include with each species.
# a "dispersal" trait is implicitly added in any case.
trait_names = c("dispersal")
# ranges to scale the input environments with:
# not listed variable:         no scaling takes place
# listed, set to NA:           env. variable will be scaled from [min, max] to [0, 1]
# listed with a given range r: env. variable will be scaled from [r1, r2] to [0, 1]
environmental_ranges = list( )
```
>***Observer***
>```{r eval=FALSE}
end_of_timestep_observer = function(data, vars, config){
  # the list of all species can be found in data$all_species.
  # the current landscape can be found in data$landscape.
}
```
>***Initialization***
>```{r eval=FALSE}
# the initial abundance of a newly colonized cell, both during setup and later when 
# colonizing a cell during the dispersal.
initial_abundance = 1
# place species in the landscape:
create_ancestor_species <- function(landscape, config) {
 stop("create the initial species here")
}
```
>***Core Processes***
>```{r eval=FALSE}
### Dispersal
# the maximum range to consider when calculating the distances from local distance inputs.
max_dispersal <- Inf
# returns n dispersal values.
get_dispersal_values <- function(n, species, landscape, config) {
  stop("calculate dispersal values here")
}
### Speciation
# threshold for genetic distance after which a speciation event takes place.
divergence_threshold = NULL
# factor by which the divergence is increased between geographically isolated population.
# can also be a matrix between the different population clusters.
get_divergence_factor <- function(species, cluster_indices, landscape, config) {
  stop("calculate divergence factor here")
}
### Evolution
# mutate the traits of a species and return the new traits matrix.
apply_evolution <- function(species, cluster_indices, landscape, config) {
  stop("mutate species traits here")
}
### Ecology
# called for every cell with all occurring species, this function calculates abundances and/or who survives for each sites
# returns a vector of abundances.
# set the abundance to 0 for every species supposed to die.
apply_ecology <- function(abundance, traits, environment, config) {
  stop("calculate species abundances and deaths here")
}
```
:::

Note that the main core functions have stop warnings by default, this forces the configuration to be edited according to the rules and assumptions (model) that is to be created. You can do this from scratch or by modifying an existing config.

## 2. Modify a config {#modify}

A configuration object can be modified by editing a file or the config object in R. Here we will load the config_worldcenter.R as an R object and modify it's random seed.

```{r eval=TRUE}
# get data path
datapath <- system.file(file.path("extdata", "WorldCenter"), package="gen3sis")
# creates config object from config file
config_object <- create_input_config(file.path(datapath, "config/config_worldcenter.R"))
# modify random seed
config_object$gen3sis$general$random_seed <- 2020
```

Like so, functions and parameters can be conveniently changed and simulated in gen3sis. Remember that *run_simulation* works either with a path to a config file or config object, so we can run the old and the new modified config.

```{r eval=F}
# run simulation by indicating config file path
sim_old <- run_simulation(config = file.path(datapath, "config/config_worldcenter.R"), 
               landscape = file.path(datapath, "landscape"))

# run simulation by indicating config object
sim_new <- run_simulation(config = config_object, 
               landscape = file.path(datapath, "landscape"))

```
## 3. Explore example config elements {#explore}

Here we will go bit by bit of the config used at the [introduction.html](this vignette) vignette. We will follow the structure presented above.

## **Content of config.empty.R**

## ***Settings***
>```{r eval=FALSE}
# set the random seed for the simulation.
random_seed = NA
# set the starting time step or leave NA to use the earliest/highest time-step.
start_time = NA
# set the end time step or leave as NA to use the latest/lowest time-step (0).
end_time = NA
# maximum total number of species in the simulation before it is aborted.
max_number_of_species = 25000
# maximum number of species within one cell before the simulation is aborted.
max_number_of_coexisting_species = 2500
# a list of traits to include with each species.
# a "dispersal" trait is implicitly added in any case.
trait_names = c("dispersal")
# ranges to scale the input environments with:
# not listed variable:         no scaling takes place
# listed, set to NA:           env. variable will be scaled from [min, max] to [0, 1]
# listed with a given range r: env. variable will be scaled from [r1, r2] to [0, 1]
environmental_ranges = list( )
```
## ***Observer***
>```{r eval=FALSE}
end_of_timestep_observer = function(data, vars, config){
  # the list of all species can be found in data$all_species.
  # the current landscape can be found in data$landscape.
}
```
>***Initialization***
>```{r eval=FALSE}
# the initial abundance of a newly colonized cell, both during setup and later when 
# colonizing a cell during the dispersal.
initial_abundance = 1
# place species in the landscape:
create_ancestor_species <- function(landscape, config) {
 stop("create the initial species here")
}
```
>***Core Processes***
>```{r eval=FALSE}
### Dispersal
# the maximum range to consider when calculating the distances from local distance inputs.
max_dispersal <- Inf
# returns n dispersal values.
get_dispersal_values <- function(n, species, landscape, config) {
  stop("calculate dispersal values here")
}
### Speciation
# threshold for genetic distance after which a speciation event takes place.
divergence_threshold = NULL
# factor by which the divergence is increased between geographically isolated population.
# can also be a matrix between the different population clusters.
get_divergence_factor <- function(species, cluster_indices, landscape, config) {
  stop("calculate divergence factor here")
}
### Evolution
# mutate the traits of a species and return the new traits matrix.
apply_evolution <- function(species, cluster_indices, landscape, config) {
  stop("mutate species traits here")
}
### Ecology
# called for every cell with all occurring species, this function calculates abundances and/or who survives for each sites
# returns a vector of abundances.
# set the abundance to 0 for every species supposed to die.
apply_ecology <- function(abundance, traits, environment, config) {
  stop("calculate species abundances and deaths here")
}
```
:::




The configuration object (Figure 1 B), also required by the function contains the biological parameters that describe the rules of evolution, as well as technical parameters, such as seeding. The function “write_config_skeleton (“my_config.R”) creates a skeleton config file, which can then be changed by the user. 

The initialization function creates the ancestor species at the start of the simulation. Users can define the number of ancestor species, their distribution within the ancient landscape and their trait values. With the observer function, changes over time in any abiotic or biotic information of the virtual world can be recorded by defining the outputs that are saved at specified time steps, and results can be saved and plotted in real-time as the model runs. 