---
title: "Creating input in gen3sis"
date: "`r format(Sys.time(),  '%d.%m.%Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Creating input objects}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette aims at showing how to use the function create_input(). The function create_input() creates input objects necessary to run gen3sis: 1) a rds file containing a landscape list of raster stacks for environmental variables; 2) a series os rds files, one for each timestep, including distance matrices between grid cells. To create these files, the function requires as arguments: A) a list of data frames, with each data frame containing the spatio-temporal distribution of an environmental variable; B) a cost function defining how dispersal between particular types of cells is penalized (to be used for the calculation of the distance matrices); C) A predefined directory where the created files will be saved to file. Further arguments can be modified from the default values depending on user preferences. Below, we go step by step to generate the R objects required by the function create_input(). For this exercise, we will use the simple island landscape that we used in the introduction vignette and in the main text of the package manuscript as case study 1. This example is important, because the user will define each required object him/herself.
The first step is to load the package library:

```{r setup}
library(gen3sis)
```

## Creating the environmental data frame
In this step, the user needs to create the data frames containing the spatiotemporal distribution of the environmental variables of interest. For our example, we need to create a dynamic island landscape that starts with few grid cells, grows in number of grid cells as mimicking volcanic activity, then shrinks in number of cells in a slower pace as mimicking erosion. Within this dynamic landscape, we define the value of the environmental variables in each cell. We define temperature in Celcius and Precipitation in mm per year. In this experiment, we assume that the island just increases in size, with not environmental gradient emerging. However, we do want to add some temporal dynamics in the environment. For this we add a Gaussian environmental white noise by choosing a mean and a standard deviation for each parameter. From these mean and standard deviation parameters, we draw a random number for each environmental variable for every cell and for every timestep.
The code to generate such dynamic landscape is below:

```{r eval=TRUE}
#Set the work directory of your choice in which you will save the landscape files
setwd(getwd())
#Defining spatial extents in two dimensions (number of grid cells):
Ncol<-31
Nrow<-31
#Defining temporal extent (number of time steps):
Ntimesteps<-140
#Creating two 3D arrays to save variable values (2 spatial dimensions and 1 temporal dimension) for landscape input file
#and two matrices for later calculation of distance matrices input files
#each pair of array and matrix for an environmental variable (e.g. temperature and precipitation):
#Temperature :
Dynamic_Landscape_Temperature<-array(NA,dim=c(Nrow,Ncol,Ntimesteps))
Dynamic_Landscape_Temperature_dataframe<-matrix(NA,nrow=Nrow*Ncol, ncol=length(c(Ncol,Nrow))+Ntimesteps)
#Precipitation:
Dynamic_Landscape_Precipitation<-array(NA,dim=c(Nrow,Ncol,Ntimesteps))
Dynamic_Landscape_Precipitation_dataframe<-matrix(NA,nrow=Nrow*Ncol, ncol=length(c(Ncol,Nrow))+Ntimesteps)
#Creating a vector for the names to be used to name input files (one per time step) 
stringtimestepsnames<-vector(mode="character",length=Ntimesteps)

#Looping over the time steps and spatial dimentions,
#generating the area and heterogeneity dynamics over time,
#generating the environmental values to be saved in the landscape arrays:
for (timestep in 1:Ntimesteps){ # temporal loop
  counting<-1
  stringtimestepsnames[timestep]<-paste(timestep," Ma", sep="")
  for (y in 1:Nrow){ #loop over the first spatial dimension
    for (x in 1:Ncol){ #loop over the second spatial dimension
      if((timestep<=10)||(timestep>120 && timestep<=140)){#time steps with only four (2x2) suitable grid cells
        if((y>=15 && y<=16)&&(x>=15 && x<=16)) {  #suitable grid cells
          Dynamic_Landscape_Temperature[x,y,timestep] <- rnorm(1,20,0.5) #temperature: environmental white noise in space and time of 20 C average +- 0.5 C standard deviation
          Dynamic_Landscape_Precipitation[x,y,timestep] <- rnorm(1,500,50) #precipitation: environmental white noise in space and time of 500 mm/year average +- 50 mm/year standard deviation
        }
      }
      if((timestep>10 && timestep<=20)||(timestep>100 && timestep<=120)){#time steps with nine (3x3) suitable grid cells
        if((y>=15 && y<=17)&&(x>=15 && x<=17)) {
          Dynamic_Landscape_Temperature[x,y,timestep] <- rnorm(1,20,0.5) 
          Dynamic_Landscape_Precipitation[x,y,timestep] <- rnorm(1,500,50)
        }
      }
      if((timestep>20 && timestep<=30)||(timestep>80 && timestep<=100)){#time steps with 25 (5x5) suitable grid cells
        if((y>=14 && y<=18)&&(x>=14 && x<=18)) {
          Dynamic_Landscape_Temperature[x,y,timestep] <- rnorm(1,20,0.5) 
          Dynamic_Landscape_Precipitation[x,y,timestep] <- rnorm(1,500,50) 
        }
      }
      if((timestep>30 && timestep<=40)||(timestep>60 && timestep<=80)){#time steps with 49 (7x7) suitable grid cells
        if((y>=13 && y<=19)&&(x>=13 && x<=19)) {
          Dynamic_Landscape_Temperature[x,y,timestep] <- rnorm(1,20,0.5)
          Dynamic_Landscape_Precipitation[x,y,timestep] <- rnorm(1,500,50)
        }
      }
      if(timestep>40 && timestep<=60){#time steps with 81 (9x9) suitable grid cells
        if((y>=12 && y<=20)&&(x>=12 && x<=20)) {
          Dynamic_Landscape_Temperature[x,y,timestep] <- rnorm(1,20,0.5)
          Dynamic_Landscape_Precipitation[x,y,timestep] <- rnorm(1,500,50)  
        }
      }
      #Saving the environmental variables in a table format for distance matrices
      if(timestep==1){
        Dynamic_Landscape_Temperature_dataframe[counting,1]<-x
        Dynamic_Landscape_Temperature_dataframe[counting,2]<-y
        Dynamic_Landscape_Precipitation_dataframe[counting,1]<-x
        Dynamic_Landscape_Precipitation_dataframe[counting,2]<-y
      }
      Dynamic_Landscape_Temperature_dataframe[counting,2+timestep]<-My_Dynamic_Landscape[x,y,timestep]
      Dynamic_Landscape_Precipitation_dataframe[counting,2+timestep]<-My_Dynamic_Landscape2[x,y,timestep]
      counting<-counting+1
    }
  }
}


#Data frame for temperature:
Dynamic_Landscape_Temperature_dataframe<-as.data.frame(Dynamic_Landscape_Temperature_dataframe)
colnames(Dynamic_Landscape_Temperature_dataframe)<- c("x","y",stringtimestepsnames)
#Data frame for precipitation:
Dynamic_Landscape_Precipitation_dataframe<-as.data.frame(Dynamic_Landscape_Precipitation_dataframe)
colnames(Dynamic_Landscape_Precipitation_dataframe)<- c("x","y",stringtimestepsnames)


```
## creating a list with the environmental dataframes
It is important to add the name of the environmental variable you want to use in the list, which will be used when specifying the config file. Here we name "temp" the data frame for temperature and "prec" for the data frame for precipitation
```{r eval=True}
Landscapes_list <- list("temp" = Dynamic_Landscape_Temperature_dataframe,"prec"=Dynamic_Landscape_Precipitation_dataframe) 

```
## Defining a cost function (how connected and reachabel grid cells are)

```{r eval=FALSE}
dir <- getwd()
setwd("../input/IntegrationTests_scaled_4d_restructured/")
all_geo_hab <- readRDS("all_geo_hab.rds")
dir.create("temp_raster")

temp <- all_geo_hab$temp
rasters <- list()
for(i in 3:303){ #per zeitschritt
  ras <- rasterFromXYZ(temp[, c(1,2,i)])
  rasters[[304-i]] <- ras
}
timesteps <- rev(colnames(temp)[-c(1,2)])  #names der Zeitschritten

landscapes <- list(temp = rasters)

cost_function <- function(x, h_x, y, h_y){
  if(all(h_x, h_y)){
    return(1)
  } else {
    return(2)
  }
}



```
## create input 

The distance matrix for each time step between either: (i) full distance, containing all habitable cells in the landscape (faster computing speed, larger storage required), or (ii) local distance, containing a list of distance matrices of each cell with its 16 neighbors (slower computing speed, smaller storage required). Local distances matrix are built at each timestep with equal dimension to the full distances during a simulation run.The real geographic coordinate system can be provided which allows for the global spherical distance correction. For real landscapes, the distance unit is in kilometers (km). In the case of hypothetical landscapes, geographic distance is measured in units of grid cells.The model uses serialized R files (rds) format for all inputs. The functions for processing the input data in the required format are available in the package. The package offers two options to create distance matrices: one can either compute a (i) full distance matrix at each time step, or compute a (ii) local distance matrix of all cells containing the distances between neighbouring cells. The former option will lead to faster simulations, while the latter uses less storage space. Once the data is processed, the simulation can be started with the function ‘run_simulation’.’ 

```{r eval=FALSE}
create_input(landscapes = landscapes,
             cost_function = cost_function,
             directions = 8,#p o gdistance calculat distancias, 16 better for more complex landscape shapes  # o mesmo argumento usado na funcao transition no package gdistance  gdistance::transition
             output_directory = "../IntegrationTests_4d_new_layout",# an existing directory to put all
             timesteps = as.character(timesteps), #just to name the files, e.g. paste(0:140, "Ma") inside the landscape
             calculate_full_distance_matrices = T  #for all cells (full) or just neigbors (local[less space in the disc, but cost more time, because the full is recalculated everytime step])
)
```
