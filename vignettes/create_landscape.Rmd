---
title: "Creating Landscapes in gen3sis"
date: "`r format(Sys.time(),  '%d.%m.%Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Creating Landscapes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

To create your own landscape, you can start from anywere. For this exercise we will create a simple island landscape that we used in the main text of the package manuscript as case study 1.




## Create your rasters

The case study one explores biodiversity dynamics and trait evolution on dynamic oceanic islands. It follows the general dynamic model of island biogeography (Whittaker et al. 2008 Journal of Biogeography), but the island dynamics entails only area dynamics.

First, we set up our R session and set the working directory where we will save the landscape files.
```{r setup, message=F}
library(gen3sis)
library(raster)
library(landscapetools)
library(NLMR)

setwd(getwd())
```


We will now create the landscape files for the experiment. First, we will define the spatial extent of our landscape, i.e. the number of grid cells. In our case, this will be 31 by 31 cells. Next we specify that our landscape should evolve over 140 time steps.


```{r eval=FALSE}
Ncol<-31
Nrow<-31

Ntimesteps<-140
```

The next step will be to create two empty 3 dimensional arrays (2 spatial dimensions and 1 temporal dimension). In here, we will save the environmental variable values for the landscape file. Additionally we create two matrices (again, one for each environmental variable) which will later serve for the calculation of the distance matrices input files. 

```{r eval=FALSE}
#Create the temperature array and matrix:
My_Dynamic_Landscape<-array(NA,dim=c(Nrow,Ncol,Ntimesteps))
My_Dynamic_Landscape_dataframe<-matrix(NA,nrow=Nrow*Ncol, ncol=length(c(Ncol,Nrow))+Ntimesteps)

#Create the precipitation array and matrix:
My_Dynamic_Landscape2<-array(NA,dim=c(Nrow,Ncol,Ntimesteps))
My_Dynamic_Landscape_dataframe2<-matrix(NA,nrow=Nrow*Ncol, ncol=length(c(Ncol,Nrow))+Ntimesteps)

#Creating a vector for the names to be used to name input files (one per time step) 
stringtimestepsnames<-vector(mode="character",length=Ntimesteps)
```

Now that our template arrays and matrices are prepared, we can start to fill them with environmental values. We will use three nested loops to do so. The first loop iterates over the 140 time steps, while the two inner ones iterate over all spatial cells. We thus create the enironmental values which will be saved in the corresponding landscape arrays and therefore generate a heterogenous and temporally dynamic landscape.

For both temperature and precipitation we create a uniform distribution of the values over space and then add environmental white noise to introduce spatial and temporal heterogenity. For the temperature layer this will be an average of 20° with a standard deviation of 0.5°, where as for precipitation we settle for an average value of 500 mm/year with a standard deviation of 50 mm/year.

```{r eval=FALSE}
for (timestep in 1:Ntimesteps){ # temporal loop
  counting<-1
  stringtimestepsnames[timestep]<-paste("X",timestep,"", sep="")
  for (y in 1:Nrow){ #loop over the first spatial dimension
    for (x in 1:Ncol){ #loop over the second spatial dimension
      if((timestep<=10)||(timestep>120 && timestep<=140)){#time steps with only four (2x2) suitable grid cells
        if((y>=15 && y<=16)&&(x>=15 && x<=16)) {  #suitable grid cells
          My_Dynamic_Landscape[x,y,timestep] <- rnorm(1,20,0.5) #temperature
          My_Dynamic_Landscape2[x,y,timestep] <- rnorm(1,500,50) #precipitation
        }
      }
      if((timestep>10 && timestep<=20)||(timestep>100 && timestep<=120)){#time steps with nine (3x3) suitable grid cells
        if((y>=15 && y<=17)&&(x>=15 && x<=17)) {
          My_Dynamic_Landscape[x,y,timestep] <- rnorm(1,20,0.5) 
          My_Dynamic_Landscape2[x,y,timestep] <- rnorm(1,500,50)
        }
      }
      if((timestep>20 && timestep<=30)||(timestep>80 && timestep<=100)){#time steps with 25 (5x5) suitable grid cells
        if((y>=14 && y<=18)&&(x>=14 && x<=18)) {
          My_Dynamic_Landscape[x,y,timestep] <- rnorm(1,20,0.5) 
          My_Dynamic_Landscape2[x,y,timestep] <- rnorm(1,500,50) 
        }
      }
      if((timestep>30 && timestep<=40)||(timestep>60 && timestep<=80)){#time steps with 49 (7x7) suitable grid cells
        if((y>=13 && y<=19)&&(x>=13 && x<=19)) {
          My_Dynamic_Landscape[x,y,timestep] <- rnorm(1,20,0.5)
          My_Dynamic_Landscape2[x,y,timestep] <- rnorm(1,500,50)
        }
      }
      if(timestep>40 && timestep<=60){#time steps with 81 (9x9) suitable grid cells
        if((y>=12 && y<=20)&&(x>=12 && x<=20)) {
          My_Dynamic_Landscape[x,y,timestep] <- rnorm(1,20,0.5)
          My_Dynamic_Landscape2[x,y,timestep] <- rnorm(1,500,50)  
        }
      }
      #Saving the environmental variables in a table format for distance matrices
      if(timestep==1){
        My_Dynamic_Landscape_dataframe[counting,1]<-x
        My_Dynamic_Landscape_dataframe[counting,2]<-y
        My_Dynamic_Landscape_dataframe2[counting,1]<-x
        My_Dynamic_Landscape_dataframe2[counting,2]<-y
      }
      My_Dynamic_Landscape_dataframe[counting,2+timestep]<-My_Dynamic_Landscape[x,y,timestep]
      My_Dynamic_Landscape_dataframe2[counting,2+timestep]<-My_Dynamic_Landscape2[x,y,timestep]
      counting<-counting+1
    }
  }
  #subsetting only the suitable grid cells from the matrix:
  My_Dynamic_Landscape_dataframe_suitable<-My_Dynamic_Landscape_dataframe[which(My_Dynamic_Landscape_dataframe[,2+timestep]>0),]
  #calculating distance matrices
  if(is.null(dim(My_Dynamic_Landscape_dataframe_suitable))) dist_matrx<-as.matrix(dist(My_Dynamic_Landscape_dataframe_suitable[1:2], method = "euclidean"))
  else dist_matrx<-as.matrix(dist(My_Dynamic_Landscape_dataframe_suitable[,1:2], method = "euclidean"))
  ##saving the distance matrix into .rds format to be used as input per time step
  saveRDS(dist_matrx, paste(getwd(),"/input/my_experiment/distance_matrices/distances_full_",(Ntimesteps - timestep),".rds", sep=""))

}


#Data frame for temperature:
My_Dynamic_Landscape_dataframe<-as.data.frame(My_Dynamic_Landscape_dataframe)
colnames(My_Dynamic_Landscape_dataframe)<- c("x","y",stringtimestepsnames)
#Data frame for precipitation:
My_Dynamic_Landscape_dataframe2<-as.data.frame(My_Dynamic_Landscape_dataframe2)
colnames(My_Dynamic_Landscape_dataframe2)<- c("x","y",stringtimestepsnames)

#binding both data frames in a list object:
all_geo_hab <- list("temp" = My_Dynamic_Landscape_dataframe,"prec"=My_Dynamic_Landscape_dataframe2) #This is important, otherwise the objects in the list won't have a name

##saving the list of data frames into .rds format to be used as input
saveRDS(all_geo_hab, paste(getwd(),"/input/my_experiment/landscapes.rds", sep=""))


```
## Add environmental characteristics

## Add a resistance (how connected and reachebel things are)

The distance matrix for each time step between either: (i) full distance, containing all habitable cells in the landscape (faster computing speed, larger storage required), or (ii) local distance, containing a list of distance matrices of each cell with its 16 neighbors (slower computing speed, smaller storage required). Local distances matrix are built at each timestep with equal dimension to the full distances during a simulation run.The real geographic coordinate system can be provided which allows for the global spherical distance correction. For real landscapes, the distance unit is in kilometers (km). In the case of hypothetical landscapes, geographic distance is measured in units of grid cells.The model uses serialized R files (rds) format for all inputs. The functions for processing the input data in the required format are available in the package. The package offers two options to create distance matrices: one can either compute a (i) full distance matrix at each time step, or compute a (ii) local distance matrix of all cells containing the distances between neighbouring cells. The former option will lead to faster simulations, while the latter uses less storage space. Once the data is processed, the simulation can be started with the function ‘run_simulation’.’ 